import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.Instant;
import java.util.ArrayList;

import org.joda.time.DateTime;

import java.sql.Date;

/**
 * Class used to format and use data from MySQL Databases
 * @author jlars
 */
public class SQLRetrieve {

	private ArrayList<WeatherData> wd;
	private Credentials credentials;
	private int hours;
	
	/**
	 * Creates an SQLRetrieve object with an autogenerated {@link Credentials} Object
	 * @param hours number of entries to acquire, from current hour
	 */
	public SQLRetrieve(int hours) {
		wd = new ArrayList<WeatherData>();
		credentials = new Credentials();
		this.hours = hours;
	}
	/**
	 * Fills the WeatherData ArrayList with selected number of entries from time series database
	 */
	public void getData() {
		try {
			Connection dbConn = credentials.establishDBConnection();
			
			if(dbConn == null) return;
			
			DateTime utilDate = new DateTime();
			Date sqlDate = new Date(Instant.now().toEpochMilli());
			int hour = utilDate.getHourOfDay()-hours;
			String query = "SELECT * FROM weather WHERE date >= " +sqlDate + " AND WHERE hour BETWEEN "+ hour + " AND " + hour+hours;
			PreparedStatement pst = dbConn.prepareStatement(query);
            ResultSet rs = pst.executeQuery();
			while(rs.next()) {
				wd.add(new WeatherData(rs.getDate("date"), rs.getInt("hour"), rs.getDouble("temperature"), 
						rs.getLong("humidity"), rs.getLong("pressure")));
			}
		} catch (SQLException e) {
			
		}
	}
	
	/**
	 * Checks to see if data acquired exists fully, then returns the list.
	 * @return verified list of WeatherData
	 */
	
	public ArrayList<WeatherData> getWeatherData() {
		boolean isFull = true;
		for(int i = 0; i < hours; i++) {
			if(wd.get(i) == null) isFull = false;
		}
		if(!isFull) {
			System.out.println("Forecast cannot be made, insufficient data");
			return null;
		} else {
			return wd;
		}
	}

}
